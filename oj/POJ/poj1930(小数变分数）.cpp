/*
纯循环

9做分母，有几个循环数，就有几个9，例如0.3就是9分之3，0.654就是999分之654。。等等

混循环

把0.228转换成分数(8是循环节)
=[（228/1000）+8/9000）]
=228/（900+100）+8/9000
=[（228/900）-（228/9000）]+（8/9000）
=（228/900）+[（8/9000）-（228/9000）]
=（228/900）-（22/900）
=（228-22）/900
=206/900
=103/450；

0.123B68B=(0.12368+0.00000B68B)
=(12368/100000)+（68/9900000）
=[（12368/99000）-（12368/990000）]+（68/9900000）
=（12368/99000）+[（68/9900000）-（12368/9900000）]
=（12368/99000）-（12300/9900000）
=(12368-123)/99000

公式
用9和0做分母，首先有几个循环节就几个9，接着有几个没加入循环的数就加几个0，再用小数点后面的数减 没加入循环的数，比如0.43，3的循环，有一位数没加入循环，就在9后面加一个0做分母，再用43减4做分子，得 90分之39，0.145，5的循环就用9后面加2个0做分母，再用145减14做分子，得900分之131，0.549，49的循环，就 用99后面加1个0做分母，用549减5做分子，最后得990分之545，以此类推，能约分的要化简。

题目没说循环小数从哪一点开始，直接枚举即可。
*/


#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;
   ll gcd(ll a,ll b)                     //两个自然数的乘积等于这两个自然数的最大公约数和最小公倍数的乘积
    {
        return (b==0)?a:gcd(b,a%b);
    }

int zero(char s[],int len)
{
	for(int i=2;i<len-3;++i)
	{
		if(s[i]!='0')
		{
			return 0;
		}
	}
	return 1;
}
int main()
{
	char s[105];
	while(~scanf("%s",s))
	{
		if(s[0]=='0'&&s[1]==0)
		{
			break;
		}
		ll len=strlen(s);
		if(zero(s,len))
		{
			printf("0/1\n");
			continue;
		}
		ll ansx,ansy=1<<31-1;
		for(ll pos=2;pos<len-3;++pos)
		{
			ll a=0,x=1;//不循环部分
			for(ll i=2;i<pos;++i)
			{
				a=a*10+s[i]-'0';       //a是不循环部分
				x*=10;                  //x是“长度
			}
			ll b=0,y=0,z=1;//循环部分
			for(ll i=pos;i<len-3;++i)
			{
				b=b*10+s[i]-'0';
				y=y*10+9;
				z*=10;
			}
			y*=x;                     //此时y是99000
			ll ty=y,tx=a*z+b-a;
			ll tp=gcd(tx,ty);
			tx/=tp;ty/=tp;
			if(ty<ansy)
			{
				ansx=tx;ansy=ty;        //寻找分母最小的解
			}
		}
		printf("%lld/%lld\n",ansx,ansy);
	}
	return 0;
}
