1^3+2^3+...+n^3=(n*(n+1)/2)^2
1^2+2^2+...+n^2=n*(n+1)*(2n+1)/6

1./向零取整，x+y-x/2是为了使分界点更靠近开始点

2.[x,y)->[x,m），[m,y）所以取左闭右开

3.最大连续和  O（n）  记录最小的s【j】

4.归并排序 

mergesort
（逆序对问题 else A【i++】=T【j++】，ans+=m-j）

快速排序
三步:
划分
递归求解（两边排序）
合并（这一步不用再排序）
快速选择问题（第k小） 根据划分阶段的p-q，q-r，根据k和q的关系，只在左边或右边递归求解

二分查找
二分查找返回中间的v
若想找最后或合适的插入位置，就要用lower_bound，
lower和upper的实现  
（if(A【m】)>=v）y=m；else x=m+1）returnx  （lowerbound）
（if(A【m】)<=v）x=m+1；else y=m）returnx  （upperbound）

5.递归与分治  

思路重要 划分为小的类似的问题，递归


棋盘覆盖问题 （分为4块）
循环日程表  （左上角+4构成左下角，右下角等于左上角，右上=左下）
巨人和鬼

6.贪心
部分背包
乘船问题 （i++，j--）

区间相关问题 
区间不相交问题，区间选点问题  先按b从小到大，再按a
区间覆盖问题  先从s开始，去掉多余部分（预处理），找到最长的，再从b1开始，递推下去 

霍夫曼编码
前缀码：任一字符编码不是另一个字符的前缀
结论: 编码树满足字符编码

霍夫曼编码:子树的权值等于相应字符的频率，每次取权值最小的子树合成新树，再放到集合中
霍夫曼编码的证明：贪心选择保留最优解，原问题的最优解包含子问题的最优解（最优子结构性质）
f(z)为频率。z为x,y的父节点
先把字符按频率从小到大排在P里，再建立新节点队列Q。
第一步从P里找到前两个（频率最小），合并放到Q。然后每次选频率最小的点（P+Q）合并放到Q
由于排序，后加入的节点一定大于之前的节点
复杂度O（n）（只需要检查P，Q最前面的点）
加上排序，O（nlogn）



