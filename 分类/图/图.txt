点v，边e，e（u，v）  G（V,E）
边有权值
无向图 ：相邻点间为路径（此相邻不是彼） 起点终点重合的路径为圈 任意两点间有路径，称为连通图 顶点所连边数称为该点的度
没有圈的连通图为树，树的边数等于顶点数-1（充要）有根无根数

有向图：+v，-v  |+v|出度 |-v|入度   
无圈的有向图为DAG若第i号顶点编号为vi，存在vi到vj的边，则有i<j，这样为拓扑序，求解拓扑序的算法为拓扑排序。应用拓扑排序的DAG问题，可以利用DP

图的表示：邻接矩阵 用v*v的数组来表示，g[I]IJ]表示ij间的关系 ，无向图ij=ji=0/1，有向图则不需要  带权图不能用0表示有无连接，应用inf或其他合适的值
优点可以快速查处有无边  缺点，空间大；不能表示重边，自接边
可以用邻接表克服，空间V+E；存入边     缺点是需要遍历链表才能知道结果



前向星
https://www.cnblogs.com/zmin/p/7349100.html
前向星是一种特殊的边集数组,我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序,
并记录下以某个点为起点的所有边在数组中的起始位置和存储长度,那么前向星就构造好了.
用len[i]来记录所有以i为起点的边在数组中的存储长度.
用head[i]记录以i为边集在数组中的第一个存储位置.
我们输入边的顺序为:
1 2
2 3
3 4
1 3
4 1
1 5
4 5
那么排完序后就得到: 
编号:     1      2      3      4      5      6      7
起点u:    1      1      1      2      3      4      4
终点v:    2      3      5      3      4      1      5
得到:
head[1] = 1    len[1] = 3
head[2] = 4    len[2] = 1
head[3] = 5    len[3] = 1
head[4] = 6    len[4] = 2
但是利用前向星会有排序操作,如果用快排时间至少为O(nlog(n))
链式前向星，以避免排序
struct Edge
{
     int next;
     int to;
     int w;
};
其中edge[i].to表示第i条边的终点,
edge[i].next表示与第i条边同起点的下一条边的存储位置,
edge[i].w为边权值.
另外还有一个数组head[x],它是用来表示以x为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实在以x为起点的所有边的最后输入的那个编号.
head[]数组一般初始化为-1,对于加边的add函数是这样的:

void add(int u,int v,int w)
{
    edge[cnt].w = w;
    edge[cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}
初始化cnt = 0,这样,现在我们还是按照上面的图和输入来模拟一下:
edge[0].to = 2;     edge[0].next = -1;      head[1] = 0;
edge[1].to = 3;     edge[1].next = -1;      head[2] = 1;
edge[2].to = 4;     edge[2],next = -1;      head[3] = 2;
edge[3].to = 3;     edge[3].next = 0;       head[1] = 3;
edge[4].to = 1;     edge[4].next = -1;      head[4] = 4;
edge[5].to = 5;     edge[5].next = 3;       head[1] = 5;
edge[6].to = 5;     edge[6].next = 4;       head[4] = 6;
很明显,head[i]保存的是以i为起点的所有边中编号最大的那个,而把这个当作顶点i的第一条起始边的位置.
这样在遍历时是倒着遍历的,也就是说与输入顺序是相反的,不过这样不影响结果的正确性.
比如以上图为例,以节点1为起点的边有3条,它们的编号分别是0,3,5   而head[1] = 5
我们在遍历以u节点为起始位置的所有边的时候是这样的:
for(int i=head[u];~i;i=edge[i].next)
那么就是说先遍历编号为5的边,也就是head[1],然后就是edge[5].next,也就是编号3的边,然后继续edge[3].next,也
就是编号0的边,可以看出是逆序的.


最小着色数为2的图为二分图
二分图判断：dfs   O（|V|+|E|）（由于只访问一遍）
注意题目无描述，图可能是不连通的，要将dfs稍作修改   

下面要注意紫书和白书的细节区别
最短路问题
边的权值最小
 负圈又称负环,就是说一个全部由负权的边组成的环,这样的话不存在最短路,因为每在环中转一圈路径总长就会边小

单源最短路 1.bellman-ford算法 O(|v|*|E|);可以检查负圈
                  2.dijkstra算法  没有负边的情况下再用；O(|E|log|V|)   （求次短路，poj3255，记录到所有顶点的最短路和次短路；）
                   3.任意两点间最短路（所有两点间最短路）  floyd-warshall算法 O（|V|^3）可以判断有无负圈
路径还原：可以用cost寻找顶点j的前趋顶点；也可以用pre在寻找最短路时记录j的前趋
图的最短路问题也可以表示为：设s到u的最短路d（u），w=e（u，v），则d（u）+w>=d（v）；在满足全部的约束不等式的d中，d（v）-d（s）的最大值，即为s到v的最短距离 （注意是最大值对应最短路）
poj3169：差分约束系统，不等式两边均只有一个变量，则每一个约束不等式对应为一条边，建图；d【n】-d【v】的最大值，即为n到1的最短路


最小生成树
一个无向图某个子图中任意两点都互相连通并且是一棵树，那么这棵树就是一颗生成树（Spanning tree）；如果边有权值，使边权值和最小的生成树称为最小生成树
最大权森林问题可以将边权取反后按照最小生成树来做

prim算法 与dijkstra类似，从一个顶点出发，不断添加边O(|E|LOG|V|)
kruskal算法，O(|E|LOG|V|)


dfs求联通块
bfs求最短路


拓扑排序
若图中存在有向环，则不存在拓扑排序，反之则存在（不一定唯一）
不含有向环的有向图称为有向无环图，（DAG），用DFS实现拓扑排序；访问完一个结点后加到当前拓扑序前


欧拉回路
七桥问题；
无向图，如果一个路径一次经过全部边，该路径为欧拉路径，若一个回路是欧拉路径，称为欧拉回路；
顶点的度(degree),就是指和该顶点相关联的边数
除了起点和终点，其他进出相应，即degree为偶数
充要：若一个无向图联通，两个奇点或没有，则一定有欧拉路径；
两个奇点一个是终点，一个是起点；
无奇点，则从任一点出发，最后一定回到该点；（欧拉回路）
对有向图：忽略方向，图必须是联通的；两个点入度不等于出度
(1)一个点出度大于入度1（起点）且另一个点入度大于出度1（终点）; (2)入度都等于出度
紫书的打印，若是欧拉路径，注意参数是起点；注意是逆序，所以先push到栈内；
判断连通用DFS或并查集