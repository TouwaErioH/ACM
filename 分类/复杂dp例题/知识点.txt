1.截尾法  %.0lf floor   %.0f会自动四舍五入。需用floor截取整数部分

2.uva12105

更简单的做法：
定义状态dp[i][j]表示在已经用了i根火柴的情况下拼出来了剩余部分(是剩余部分，不是已经拼出来了的)为j(需要%m)的最大长度，一个辅助数组p[i][j]表示状态[i][j]的最高位
是往后添加k
dp[i][j]=max(dp[i][j],dp[i-c[k]][(j*10+k)%m]+1)
(这里应该要证明dp[i-c[k]][(j*10+k)%m]加了d%m=j，没证出来...
倒着枚举k，这样保证位数相同存更大的数

3.uva1336 用到了kase避免memset超时

4.uva12170 
我觉得这个题挺难的......
首先这个题的结论 hp+kd我没有证明出来（范围肯定没有问题，根据数量少的时候和感觉就觉得是对的，但是没有严格的证明)

dp[i][x]就是在dp[i-1][x-d---x+d]中找一个最小值转移，再加上常数|h[i]-x|，这样就可以用优先队列来优化。
虽然说是用单调队列来求每个滑动窗口的最小值，然而再深入分析一步就会发现一个规律，每次算完一个阶段后，该阶段的dp序列呈现的是一个先下降，后上升的趋势，而且下降时候的最低点一定是整个序列的最低点。这样，我们只需要一个front指针即可维护优先队列了。

先维护窗口左边界，别让指针k超出了窗口，如果x[k] < x[j] - d那么就k++ （因为x数组是从大到小已经排好序的），然后在不超出右边界x[j]+d 的前提下，如果dp[i][k+1] <= dp[i][k]，那么k++；

为什么这样是对的的？ 好像和之前说的单调队列一点也不一样啊！ ?其实是一样的操作，仔细回想维护单调队列时是怎么操作的 ：用两个指针front、rear 先更新左边界，防止他超出边界，一旦超出就front++； 然后每次新加进来一个值就要看看当前队列最右端的元素与新值的大小，如果大于新值那么就rear--，将无用的元素请出队列 ，直到小于新值，就将新值加入， 然而其实上边那个用一个指针的方法是如出一辙的，只不过将删除无用值这一步放到了求最小值时，也就是更新k时 。


unique函数属于STL中比较常用函数，它的功能是元素去重。即”删除”序列中所有相邻的重复元素(只保留一个)。此处的删除，并不是真的删除，而是指重复元素的位置被不重复的元素给占领了(详细情况，下面会讲)。由于它”删除”的是相邻的重复元素，所以在使用unique函数之前，一般都会将目标序列进行排序。返回iterator

5.uva1380
按紫书来
注意这道题的题目给了很大的方便，就相当于验证k是不是答案，不是的话就是k+1

6.uva12099 这道题超经典。dp和优化都值得看一看。
因为i+1只和i有关，用滚动数组节省空间
暑假第一次做感觉很困难，现在看就清晰了很多

7.uva10559
常见思路枚举最后一个方块A【j】何时消除

对于dp（i，j，k）就两种决策：转移到dp（i，p-1，0）+（j-p+1+k）^2
                                                枚举q<p，A【q】=A【j】，A【q】！=A【q+1】，转移到d（q+1，p-1,0）+dp（i，q，j-p+k）


8.uva1628
fixing great wall 的变形
dp（i，j，k，p）不考虑i-j的客人，还要送k个人，目前位置在p
起点i和总数量k都要枚举
dp（i，j，k，p）=max（dp（m，j，k-1，p）+valm，dp（i，d，k-1，p）+vald）

画一下图，就发现每个点罚时是当前k*abs【pi】

9.uva1627
注意这题要求互相认识
不认识的人之间连一条线
一个人在组1，那么不认识（互相认识）的人就在组0；同时这些人不认识的人就在组1.每个联通分量都可以独立推导，遇到矛盾则无解
一个联通分量有一个核心，其他的点是分支
我感觉紫书写的样例又是有点问题，应该是4在0，那么135在1，反正则反；而不是1在0,345在1
然后一个联通分量的核心在一组，分支就在另一组；
设0组比1组多d，就对应d加一个或者减一个值
相当于背包

矛盾状况就是任意个联通分量不能二分染色

10uva1228
这道题思维很灵活。也有点套路的意思。

首先规定0,1分别按照原来的顺序接收，只是01换位。这样简化了思维。（否则并不会有更优结果它。，比较好想）
最大值和最小值可以贪心得到。
那么接下来就是给定一个整数P，判断能不能得到它。
贪心法，从左到右判断P的每一位，从K中最左边的0或1取。
这样会发现任意时刻k中已经被接收的位最右边那那位一定没有延迟（想一想，也比较好想）
设d(i，j)表示用了k的前i个0，前k个1后形成的整数数
则下一个接收的bit是0，转移d（i+1，j）
1  则d（i，j+1）
判断下一个接受的能否为1或0
设第i个0发送时间为Zi，对应有Oi，那么Oj+d>=Zi才可以转移到i+1；j+1对应  画图证一下(用到上一个结论；比如i+1的情况，分接受的最后一位是0或1讨论；还要注意1用完了就不能这么判断了)
同时判断0,1有没有用完

这样就把十进制转化成二进制了
  for(int i = 0; i < n; i++) {
      K[n-i-1] = k % 2; k /= 2;
    }

还要注意k，min，max要用ull

11. uva1439
感觉这道题读题有点难。。似乎和现实联系的比较密切
1.每个process的两个资源可以顺序反一下
2.p->q,q->s不可以同时进行
  p->q,p->s可以

输出最长等待链
输出每个process的资源调用顺序  （注意按输入顺序输出，并不意味着按输入顺序先后执行，只是输出方便看）

把资源看成点，一个process就成了链接两个点的无向边
任务就成了把无向边定向，使其不存在圈，且最长路（也即最长等待链最短）

创造性思维：把结点分成p层，编号为0,1,2...使同层结点间没有边；对任意边u-v，定向位从层编号小的点指向层编号大的点。
则定向后的图肯定没有圈，且最长路所含点数不超过p。所以p越小越好（直观上）

可以证明p取得最小值时，最长路恰好包含p个结点，且这个结果是所有定向方案中最优的。 （证明：从定向方案构造分层图。先把所有路径的起点作为第0层。    （没证！！！））

这样问题转化为结点分层问题。也就是色数问题：将图中结点染成尽量小的颜色，使相邻结点颜色不同。
（色数问题见紫书P286）
O(3^K)k<=15.