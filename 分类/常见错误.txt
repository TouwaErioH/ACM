1.rte  :  数组越界，小了

2.cpe  命名有歧义

3.有时int太小了用long long

4.看上去很简单的题，很有可能数据范围会比较大int不够

5.string 用cin

6.pe   用空格隔开时
 cout << ans[0];
      for(int i = 1; i < ans.size(); i++) cout << " " << ans[i];

7.sizeof的用法  返回的是数组大小  s1【100】  返回100；而不是内容大小;用strlen

string 用str.size（）


8.for循环先判断

9.dp时注意边界条件或者转移方程有的达不到要求，先判断
如： if(k>1)
  d【i】【k】=d【i-1】【k-1】
10。推出公式后注意验证边界和大值；如0,1,100000；

11.讨论时可能会被题目迷惑  不要漏掉不常见的情况  如uva11346 s>ab；s_>0  fabs(x)<1e-6

12.\\勿忘转义   if s[i]='\\'  ||  '/'

13.LL b=1<<N 会有问题 （1默认int）  改为LL b=1LL<<n

14.测试一下 1 和 大数 ；       uva1213 n=k=1
  观察输出 再做修改             有的时候公式会需要稍作修改
  uva11440

15.long long tot=( long long)(2*a+1)*(2*b+1)-1;  //正确
   cout<<tot<<endl;
   long long tott=( long long)((2*a+1)*(2*b+1)-1);//这样加了括号先溢出了
   cout<<tott<<endl;

16.(ans-1+mod)%mod   防止ans-1=-1，输出-1的情况

17.数据类型不匹配  尤其是LL 和int； 函数的返回输入尤其要注意

18.超出n的范围   根据公式求的cnt ，要min（n-i，cnt）  uva1363

19设了maxn，但是数组忘了maxn+5
20.scanf==4 坑了

20.
有的编译器，计算5%3=2；有的算出来5%3=-1
为了避免两种的差别
我们统一用：ans=（ans+mod）%mod
就可以把这个都化成正的最小的那个啦

21.max 中类型应该一致，否则先转换

22.vector函数调用要加&

23.一般定义了NULL 但没得nul！！

24
结构体链表注意细节！！
头指针和新的节点都是malloc的，不是直接struct* （或者先struct*之后再=malloc也可以）

h1=h2=malloc   (错误！

25.任何累加累减累乘操作都很危险

26.局部全局变量位置

27.scanf，cin是遇到 空格 回车 和 tab键 结束输入，而gets只能遇到回车结束输入  (字符串和string