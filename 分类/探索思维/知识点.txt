1.素数分布定理   n/lnn）

2.握手定理  
3.莫比乌斯环  莫比乌斯反演
4.256mb   2*10^7 O(S）

5.memset按字节，但按位赋值

6.bitset

7.状压dp  滚动数组省空间

8.关于省空间同时省时间  cache memory disk  

9.func（const T& a） 防止T过大空间占太多，只传地址；防修改

10.new 自动初始化，malloc不会

11.cf1027d  先判断成环，再反向查找  

cf1027e根据对称，先只考虑第一个格填1，*2；  dp（i，j）  前i项连续不超过j   ；k<=min（j，i）；根据实践，写成（j，i）更方便循环；   
思路顺序：  连续不超x；x不好求，差分；dp记录不超过再减

k的范围值得关注

12. a^n-b^n==
a^n+b^n==  onlyif n=2k+1  (a+b)(a^n-1   -  a^n-2 *b +...  

13.cf235d n^2=n*(n-1)+n;   n*(n-1)=C（n，2）*2； ∑ai^2=∑ai+∑C（n，2）

化为求连续长度大于2的序列个数；
一道有意思的题。（据说是美少女（伪）计算机科学家出的，hh）

根据题目要求，就是求ni^2的和。

而n^2=n*(n-1)+n; n*(n-1)=C（n，2）*2；

所以∑ai^2=∑ai+2*∑C（n，2）

化为求连续长度大于2的序列个数；这样好像还是不太好直接做

设dp【i】=以i结尾的期望长度； dp【0】=dp【1】=0，dp【2】=p1p2，dp【3】=p1p2p3+p2p3=（dp【2】+p【2】）*p3  ...

得dp【i】=p【i】*（dp【i-1】+p【i-1】）

而发现dp【0】+dp【1】+...+dp【i】恰好包括了长度为i时序列长度超过2的所有情况，就可以接着做了



另一种思路：

设当前长为L，则下一个若也为o，那么贡献增加为(L+1)^2-L^2=2L+1 

设dp【i】=以i结尾的期望长度；

得到dp【i】=（dp【i-1】+1）*p【i】 

就可以累加了



14.1009e
简单的思路，分别写出每一站的；注意1《《2要预处理；要用LL