#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int maxn = 1005;
const LL mod = 1000000007;
LL dp[maxn][maxn];                //没有限制j的范围
LL sum[maxn][maxn];               //处理出前缀和sum[i][j]，就不用dp[i][j]了。感觉还是很巧妙的//dp[len][1] + … + dp[len][len ]=sum[len][len]
string s;                     //设dp[i][j]表示以结尾的，长度为i的排列的数目。
                               //从字符串的后面到前面DP就得出答案了。
int length;
void fdp()
{

    length = s.size()+1;
		memset(dp, 0, sizeof(dp));
		memset(sum, 0, sizeof(sum));
		dp[1][1] = 1;
		sum[1][1] = 1;
		for (int i = 2; i <= length; i++){
			for (int j = 1; j <= i; j++){
				dp[i][j] = 0;
				if (s[i - 2] == 'I' || s[i - 2] == '?'){
					dp[i][j] = (dp[i][j] + sum[i - 1][j - 1]) % mod;
				}
				if (s[i - 2] == 'D' || s[i - 2] == '?'){  //因为要令当前位为j，如果前面出现过j，就令前面的所有大于等于j的数+1，就能构造出新的排列了。比如
					dp[i][j] = (dp[i][j] + sum[i - 1][i - 1] - sum[i - 1][j - 1]) % mod;
				}
				sum[i][j] = (sum[i][j-1] + dp[i][j]) % mod;
			}
		}
}
int main(){

	while (cin >> s){
		fdp();
		cout << (sum[length][length])%mod << endl;   //+mod
	}
	return 0;
}
/*核心思想是>=i的都加1
　　分析第一个式子，假设前面i个数字所能产生的可能已经知道，那么直接将j加在最后面就行了。比如：序列3>2<4>1  共4个数字和3个符号，假设第4个符号为<，那么现在考虑第5个数字，要算的有dp[4][1] dp[4][2] dp[4][3] dp[4][4] dp[4][5]共5个。dp[4][1]可以想象将1接在序类后，即 3 2 4 1 1，疑问？这不是重复了吗？这样子我们可以将前4个数字中所有大于第5个数字的都加1，就变成4 3 5 2 1，这个序列就合法了吧？是的，对于所有的4个数字的合法序列都这么做。前提是对于第4个数字小于5的所有4数字序列才可以这么考虑。大于等于5的序列再来加1也必定重复。

　　分析第二个式子，同样，假设前面i个数字所能产生的可能已经知道，也是加在后面。比如：序列3>1<2 共3个数字和2个符号，假设第3个符号为>，那么现在考虑第4个数字，2大于1，同时还得考虑如上“加一”情况，所以1和2都要考虑。那么要计算的有dp[3][1] dp[3][2] 共2个，dp[3][3]对于我们所假设的情况是非法的。因为大于等于2的都要加一，所以dp[3][2]可能产生的序列之一为 { 3+1, 1,2+1, 2 } 即 {  4, 1,3 ,2 } 。合法！对于其他情况依此法计算。
*/