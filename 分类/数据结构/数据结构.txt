1.堆 （heap）     
n个元素，每次操作插入和删除 O(logN）
子一定不小于父
用数组储存
--
队列采用堆   push pop
优先队列先出大的


2.二叉搜索树   储存，查询，删除
左子树节点比自己小，右子树大  n个元素，每次操作 O(logN）
用类似链表的结构体储存

set，map采用二叉树  insert erase  key不可重复

平衡二叉树，解决了插入1.2.3.4.5这样使二叉树退化为O（n）  使用旋转操作


3.并查集
可以合并，无法分割
查询：两个元素是否在一组；合并两个组
每个组对应一棵树
合并：一个组的根向另一个组的根连边；
查询，向上是否找到同一根
删除见hdu2473
 大家都知道合并操作就是找到找到两个节点的父亲，修改父亲，如果删除就是将该点的父亲重新设置成自己，这样行不行呢？这是不行的，比如1，2，3的父亲都是1，现在删除1，1的父亲还是1，2,3也是1，集合还是1个，正确的应该是2个。
那删除节点的父亲不设成自己给新申请一个节点当做父亲，比如1,2,3的父亲都是1，在一个集合，现在删除1，申请了4当做1的父亲，2,3父亲都是1，然后Find(2)找2的父亲2的父亲是1，但是1的父亲是4，所以给2的父亲更新成了4,3同理，所以还不行。
正确的方法是每一个点都设立一个虚拟父亲比如1,2,3的父亲分别是4,5,6，现在合并1,2,3都在一个集合，那他们的父亲都是4，现在删除1，那就给1重新申请一个节点7
现在2,3的父亲是4,1的父亲是7，删除成功。

优化：1.记录rank，合并时rank低的为子
   2.路径压缩（查询时所有经过的节点直连根）         优化后复杂度O（a（n）） a（n）是阿克曼函数的反函数，比log还快；但是是均摊复杂度，多次操作后平均每一次的复杂度
用两个数组par 和rank  实现

以后如果看到“点合并，区间合并，并求区间值”这种问题的时候，应该要马上想到并查集



4.栈和队列
deque


5.链表不一定要用指针
用next数组记录下一个元素
uva11988
当字符频繁移动时，数组会超时，用链表；为了方便，常在前面放一个虚拟节点

双向链表 用left 和right数组记录左右
uva12657
void link(int L,int R)
{  right(L)=R;left(R)=L;}

当数据结构有一个很复杂的操作，可以用加标记的方法处理，而不需要真的执行；同时其他操作要考虑这个标记；

6.树和二叉树
二叉树的编号：根节点为1，depth为1，从左到右编号，则k的左子树为2k，右为2k+1,深度为D，节点个数为2^D-1      1<<D=2^D
二叉树的层次遍历：动态结构建树；BFS遍历；内存泄漏；数组实现二叉树；  动态化静态，内存池
二叉树的递归遍历：DFS  有先序，后序，中序遍历三种 ；  输入时就完成判断
四分树



7.图 另外一个txt


