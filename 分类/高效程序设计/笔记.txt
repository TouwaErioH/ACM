1.控制二位小数
    printf("%.2lf\n",floor(rf*100)/100);

2.二分法应用：
在有顺序数组中查找；假定一个判断是否可行（循环100次精度10e-30；或者rf-lf<  > eps）；
最大化最小值，最小化最大值； poj2456  配合贪心食用更佳；
最大化平均值；  
C（x）的设定是，最重要的

yong int x= l+ r-l/2   (防爆，防负数向零）

for(int i=1<<30;i;i>>=1)
{
if(l+i<r&&good(l+i))
l+=i;
}
return l;


3.开关问题    两次相当于没有；交换反转顺序对结果无影响

poj3276   j【i】：区间【i，i+k-1】反转为1，不反为0；   ∑ i-k+1>>>i-1  为1，则反
poj3279  由于开关性质，先枚举第一行，在枚举内部从第二行开始翻；翻完倒数第二行，若倒数第一行有反，则无效 （本题还有高斯消元法，没想）         


4.poj3684  分别分析 一个球，r=0两个球的情况； 借助画图分析；  得到规律  类似ants，但是要修正2r*i

5.折半搜索  poj2785  问题规模大，无法全面枚举；可以先枚举一半（得表，排序），然后枚举另一半  比如N^4>>N^2logN     注意：与  a+b+c+d=0  >>>a+b=-c-d  这样形式的很有关
 
6.p162之后的没看

7.LL p = ceil(a[i]*1.0/x)*x;   得大于等于p的xd最小倍数

8.upper，lower返回的是位置（3代表第四个） ；前闭后开；没有会返回越界值

9.cf818e  尺取；但是gcd有点问题，用素因子来判断整除（会感觉也更符合尺取的套路）

10.//二分，high-low=2，则mid=low+1  so that  while(high-low>1)


11.符号顺序   +-大于位移大于  == ！=   大于 & | ~  大于 &&

12.hdu 1937 预处理+尺取；；固定横向宽度，纵向尺取  （所谓固定也就是两层for循环枚举，中间套尺取）