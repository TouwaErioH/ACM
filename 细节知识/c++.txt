1.头文件，名称空间
2.cin>>a>>b;
cout<<xxx<<"\n";     或<<endl;           关闭和stdio同步   ios::sync_with_stdio(false)
3.用const不用define
const int maxn=133；  （有;）
4.bool
5.引用 代替指针
  写函数时在参数前加&
void swap2（int &a，int&b）会按引用传递，改变实参值  （swap在algorithm有，还可以交换结构体）
6.string类型  <string> 可以cin，cout读写，可以直接相加（字符数组都不行）   s+“@”+t //注意要用双引号

char a;a=cin.get;    char a[20]; cin.get(a,20);
getline(类似fgets）     getline(cin,xx,xx)        对于string类  string line; getline（cin，line）;

<sstream>   字符串流（可以直接读取）    stringstream ss(line);  while(ss>>x)   
长度  int m ;  string str;m=str.size();


7.结构体     不需要typedef；可以有函数        结构体中没有返回值的函数成为构造函数，在声明变量时调用。
如struct Point{
int x，y;
Point(int x=0,int y=0):x(x),y(y);{}
}

:x(x),y(y)     this->=x,this->y=y;    this是指向当前对象的指针，this->x相当于，（*this）.x;
Point a,b(1,2); a使用默认值，b为1,2；

定义加法
Point operator + （const Point A,const Point B）{
return Point(A.x+B.x,A.y+B.y);
}
定义输出
ostream& operator << (ostream &out,const Point &p)
{  out <<"("<<p.x<<","<<p.y<<")";
return out;
}

 struct Stu
 {
  int  nNum;
  bool bSex;
  char szName[20];
  char szEmail[100];
  //构造函数初始化
  Stu()
  {
   nNum = 0;
   bSex = false;
   memset(szName,0,sizeof(szName));
   memset(szEmail,0,sizeof(szEmail));
  }
 };
8.模板
template<typename T>
T sum（T* begin,T*end）{
T *p=begin；
T ans=0；
for （T* p=begin；p！=end；p++）
ans=ans+*p；         （注意这里的+是要被定义过的）
return ans；}

这样就可以通用各种类型  如double a[10] sum（a，a+10）;

template<typename T>
struct Point{
T  x，y;
Point(T x=0,T y=0):x(x),y(y);{}
}

template<typename T>
Point<T> operator + （const Point<T> A,const Point，<T> B）{
return Point<T>(A.x+B.x,A.y+B.y);
}
template<typename T>
ostream& operator << (ostream &out,const Point<T> &p)
{  out <<"("<<p.x<<","<<p.y<<")";
return out;
}
就可以用各种类型的Point   Point<int> a(1,2),b(3,4)

1.<cctype>
2.memset 在<cstring>里
3.fabs  在<cmath>
4.string和char
输出string用cout或.c_str（）；
赋值string s时，char c[20],strcpy（c，s.str()）
5.
struct Node {
  int r, c, dir; // 站在(r,c)，面朝方向dir(0~3分别表示N, E, S, W)
  Node(int r=0, int c=0, int dir=0):r(r),c(c),dir(dir) {}
};