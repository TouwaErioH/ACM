int 32   范围[-2^31 , 2^31 -1] 即 [-2147483648，2147483647],    1e9
%d %u

 unsigned   int   0～4294967295      
int   -2147483648～2147483647     2e9
unsigned long 0～4294967295
long   -2147483648～2147483647
long long的最大值：9223372036854775807    1e18    I64d  (is i  not L)
long long的最小值：-9223372036854775808
unsigned long long的最大值：1844674407370955161     输入输出%llu  %lld大概均可   不确定时用cin，cout

__int64的最大值：9223372036854775807
__int64的最小值：-9223372036854775808
unsigned __int64的最大值：18446744073709551615

1、编译器不同导致使用64位的申明方式不同;
2、long long / unsigned long long 一般是Linux下申明方式、如：G++
3、__int64 /unsigned __int64一般是Windows下使用64位的申明方式，如:VS
4、在赋值时需要注意加上ll进行显式赋值;
5、当进行64位与 32位的混合运算时，32位整数会被隐式转换成64位整数。
6、输出printf("");,long long使用%lld输出，__int64使用%I64d，无符号使用u替代d即可。
7、测试下来编译器一般都支持2种操作，不必太过纠结，怎么使用看个人喜欢。
//=================================华丽的分隔线
    #include<stdio.h>
    #include <stdlib.h>
    intmain()
    {
        unsigned long longa= 412432424000ll;
        unsigned __int64b= 9223372036854775808ll;
        printf("%I64u\n",a);　　　　 //使用%lld时无法正常输出，why? 解答在下面
        printf("%I64u",b);
        system("pause");
        return 0;
    }
附网友测试结果：
　　刚实验了下，在VC6、DEV、CodeBlocks中C语言都可以使用__int64，格式化输出标识为%I64d。不过在VC6中数字后加2个L是会报错，可以只加1个或不加。查了下资料，__int64是windows专用的，被vc、gcc等编译器支持，但在在UNIX、Linux中需用long long配合%lld。后者是标准C的规定!
　　我试了下long long配合%I64d，可以正确输出，而不管是long long还是__int64配合%lld都不能正确输出。所以我得出的结论是在windows下需要用longlong或，__int64配合%I64d。而在UNIX、Linux中必须使用标准C规定的long long配合%lld。





inline __int128 read()
{
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void write(__int128 x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}

注意是__ 和_t
读入和输出都要自己写